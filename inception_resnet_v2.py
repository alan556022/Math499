# -*- coding: utf-8 -*-
"""Inception_resNet_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z1zTYyly0tam1uu4O9nzb4aL2grJngWq
"""

# Import drive
from google.colab import drive
drive.mount('/content/drive')

#Login with USC gmail

from zipfile import ZipFile
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, datasets, models
import pandas as pd
import numpy as np
import cv2

from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.utils import shuffle
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Activation, Dropout, Flatten, Dense, Conv2D, MaxPooling2D, GlobalAveragePooling2D
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
from tensorflow.keras.utils import to_categorical
from tensorflow.keras import backend as K
#from tensorflow.keras.layers.core import Dense, Activation
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import categorical_crossentropy
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import Model
from tensorflow.keras.applications import imagenet_utils
from tensorflow.keras.applications import MobileNet
from tensorflow.keras.applications.mobilenet import preprocess_input

file_list = []
file_list_simple = []
labels = pd.DataFrame()
for tranch in range(1,4):

  labels_path = '/content/drive/My Drive/M499_F20_Data/tranch' + str(tranch) + '_labels.csv'
  pictures_path = '/content/drive/My Drive/M499_F20_Data/persons-posture-tranch' + str(tranch) + '.zip'

  labels_temp = pd.read_csv(labels_path)
  if tranch != 1:
    labels_temp['file_name'] = labels_temp.final_url
  
  labels = pd.concat([labels, labels_temp])

  zip_file = ZipFile(pictures_path)

  file_list_temp = [obj.filename for obj in zip_file.infolist()]
  file_list_simple_temp = [name.split('/')[-1] for name in file_list_temp]
  
  for path in file_list_temp:
    file_list.append(path)

  for name in file_list_simple_temp:
    file_list_simple.append(name)

!pip install tf_slim

from keras.layers import Input
from keras.layers.merge import concatenate, add
from keras.layers import Dense, Dropout, Lambda, Flatten, Activation, Conv2D
from keras.layers.convolutional import MaxPooling2D, AveragePooling2D
from keras.layers.normalization import BatchNormalization
from keras.models import Model
from keras import backend as K
from keras.utils.vis_utils import plot_model

RESNET_V1_A_COUNT = 0
RESNET_V1_B_COUNT = 0
RESNET_V1_C_COUNT = 0


def resnet_v1_stem(x_input):
    with K.name_scope('Stem'):
        x = Conv2D(filters=32, kernel_size=(3, 3), strides=(2, 2), activation='relu', padding='valid')(x_input)
        x = Conv2D(32, (3, 3), activation='relu', padding='valid')(x)
        x = Conv2D(64, (3, 3), activation='relu', padding='same')(x)
        x = MaxPooling2D(pool_size=(3, 3), strides=2, padding='valid')(x)
        x = Conv2D(80, (1, 1), activation='relu', padding='same')(x)
        x = Conv2D(192, (3, 3), activation='relu', padding='valid')(x)
        x = Conv2D(256, (3, 3), strides=(2, 2), activation='relu', padding='valid')(x)
        x = BatchNormalization(axis=-1)(x)
        x = Activation('relu')(x)
    return x


def inception_resnet_v1_A(x_input, scale_residual=True):
  
    global RESNET_V1_A_COUNT
    RESNET_V1_A_COUNT += 1
    with K.name_scope('resnet_v1_A' + str(RESNET_V1_A_COUNT)):
        ar1 = Conv2D(32, (1, 1), activation='relu', padding='same')(x_input)

        ar2 = Conv2D(32, (1, 1), activation='relu', padding='same')(x_input)
        ar2 = Conv2D(32, (3, 3), activation='relu', padding='same')(ar2)

        ar3 = Conv2D(32, (1, 1), activation='relu', padding='same')(x_input)
        ar3 = Conv2D(32, (3, 3), activation='relu', padding='same')(ar3)
        ar3 = Conv2D(32, (3, 3), activation='relu', padding='same')(ar3)

        merged_vector =concatenate([ar1, ar2, ar3], axis=-1)

        ar = Conv2D(256, (1, 1), activation='linear', padding='same')(merged_vector)

       #if scale_residual:  # 是否缩小
       #    ar = Lambda(lambda x: 0.1 * x)(ar)
        x = add([x_input, ar])
        x = BatchNormalization(axis=-1)(x)
        x = Activation('relu')(x)
    return x


def inception_resnet_v1_B(x_input, scale_residual=True):
   
    global RESNET_V1_B_COUNT
    RESNET_V1_B_COUNT += 1
    with K.name_scope('resnet_v1_B' + str(RESNET_V1_B_COUNT)):
        br1 = Conv2D(128, (1, 1), activation='relu', padding='same')(x_input)

        br2 = Conv2D(128, (1, 1), activation='relu', padding='same')(x_input)
        br2 = Conv2D(128, (1, 7), activation='relu', padding='same')(br2)
        br2 = Conv2D(128, (7, 1), activation='relu', padding='same')(br2)

        merged_vector = concatenate([br1, br2], axis=-1)

        br = Conv2D(896, (1, 1), activation='linear', padding='same')(merged_vector)

       #if scale_residual:
       #    br = Lambda(lambda x: 0.1 * x)(br)
        x = add([x_input, br])
        x = BatchNormalization(axis=-1)(x)
        x = Activation('relu')(x)

    return x


def inception_resnet_v1_C(x_input, scale_residual=True):
    global RESNET_V1_C_COUNT
    RESNET_V1_C_COUNT += 1
    with K.name_scope('resnet_v1_C' + str(RESNET_V1_C_COUNT)):
        cr1 = Conv2D(192, (1, 1), activation='relu', padding='same')(x_input)

        cr2 = Conv2D(192, (1, 1), activation='relu', padding='same')(x_input)
        cr2 = Conv2D(192, (1, 3), activation='relu', padding='same')(cr2)
        cr2 = Conv2D(192, (3, 1), activation='relu', padding='same')(cr2)

        merged_vector = concatenate([cr1, cr2], axis=-1)

        cr = Conv2D(1792, (1, 1), activation='relu', padding='same')(merged_vector)

     #  if scale_residual:
     #      cr = Lambda(lambda x: 0.1 * x)
        x = add([x_input, cr])
        x = BatchNormalization(axis=-1)(x)
        x = Activation('relu')(x)
    return x


def reduction_resnet_A(x_input, k=192, l=224, m=256, n=384):
    with K.name_scope('reduction_resnet_A'):
        ra1 = MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x_input)

        ra2 = Conv2D(n, (3, 3), activation='relu', strides=(2, 2), padding='valid')(x_input)

        ra3 = Conv2D(k, (1, 1), activation='relu', padding='same')(x_input)
        ra3 = Conv2D(l, (3, 3), activation='relu', padding='same')(ra3)
        ra3 = Conv2D(m, (3, 3), activation='relu', strides=(2, 2), padding='valid')(ra3)

        merged_vector = concatenate([ra1, ra2, ra3], axis=-1)

        x = BatchNormalization(axis=-1)(merged_vector)
        x = Activation('relu')(x)
    return x


def reduction_resnet_B(x_input):
    with K.name_scope('reduction_resnet_B'):
        rb1 = MaxPooling2D(pool_size=(3, 3), strides=(2, 2), padding='valid')(x_input)

        rb2 = Conv2D(256, (1, 1), activation='relu', padding='same')(x_input)
        rb2 = Conv2D(384, (3, 3), strides=(2, 2), activation='relu', padding='valid')(rb2)

        rb3 = Conv2D(256, (1, 1), activation='relu', padding='same')(x_input)
        rb3 = Conv2D(256, (3, 3), strides=(2, 2), activation='relu', padding='valid')(rb3)

        rb4 = Conv2D(256, (1, 1), activation='relu', padding='same')(x_input)
        rb4 = Conv2D(256, (3, 3), activation='relu', padding='same')(rb4)
        rb4 = Conv2D(256, (3, 3), strides=(2, 2), activation='relu', padding='valid')(rb4)

        merged_vector = concatenate([rb1, rb2, rb3, rb4], axis=-1)

        x = BatchNormalization(axis=-1)(merged_vector)
        x = Activation('relu')(x)
    return x


def inception_resnet_v1_backbone(nb_classes=1000, scale=True):
    x_input = Input(shape=(299, 299, 3))
    # stem
    x = resnet_v1_stem(x_input)

    # 5 x inception_resnet_v1_A
    for i in range(5):
        x = inception_resnet_v1_A(x, scale_residual=False)

    # reduction_resnet_A
    x = reduction_resnet_A(x, k=192, l=192, m=256, n=384)

    # 10 x inception_resnet_v1_B
    for i in range(10):
        x = inception_resnet_v1_B(x, scale_residual=True)

    # Reduction B
    x = reduction_resnet_B(x)

    # 5 x Inception C
    for i in range(5):
        x = inception_resnet_v1_C(x, scale_residual=True)

    # Average Pooling
    x = AveragePooling2D(pool_size=(8, 8))(x)

    # dropout
    x = Dropout(0.2)(x)
    x = Flatten()(x)
    x = Dense(units=nb_classes, activation='softmax')(x)

    return Model(inputs=x_input, outputs=x, name='Inception-Resnet-v1')

#***Trying Inception resNet v2
scope = inception_resnet_v1_backbone(nb_classes = 3)
scope.summary()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme(style="darkgrid")

import numpy as np
import pandas as pd
from pandas_profiling import ProfileReport